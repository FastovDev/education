**Dependency Injection (DI)** – это паттерн проектирования, позволяющий снизить связанность между компонентами системы, упростить их тестирование и повысить гибкость архитектуры. DI основан на принципе инверсии управления (Inversion of Control), когда создание и предоставление зависимостей (сервисов) делегируется внешнему контейнеру, а не реализуется внутри классов напрямую.

---

## Принципы внедрения зависимостей

1. **Инверсия управления (IoC):**  
    Вместо того чтобы класс самостоятельно создавал свои зависимости, он получает их извне. Это помогает ослабить связь между классами, повысить модульность и тестируемость.
    
2. **Абстракция зависимостей:**  
    Зависимости задаются в виде интерфейсов или абстрактных классов, а конкретные реализации инъецируются через DI-контейнер. Это позволяет легко менять реализацию без изменения кода, использующего зависимость.
    
3. **Виды внедрения:**
    
    - **Конструкторное внедрение:**  
        Наиболее популярный метод, когда зависимости передаются через параметры конструктора.
        
```C#
public interface ILogger
{
    void Log(string message);
}

public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine(message);
    }
}

public class OrderService
{
    private readonly ILogger _logger;

    // Зависимость передается через конструктор
    public OrderService(ILogger logger)
    {
        _logger = logger;
    }

    public void ProcessOrder(Order order)
    {
        // Логика обработки заказа
        _logger.Log("Order processed.");
    }
}

```
        
    - **Свойственное (property) внедрение:**  
        Зависимости устанавливаются через свойства класса. Этот метод менее популярен, так как усложняет гарантии наличия зависимости.
        
    - **Методическое (method) внедрение:**  
        Зависимости передаются в виде параметров метода, когда они нужны только для конкретного действия.
        

---

## Жизненные циклы зависимостей

DI-контейнеры позволяют управлять временем жизни зарегистрированных сервисов. Рассмотрим два основных жизненных цикла, широко используемых в ASP.NET Core:

### 1. Scoped

- **Описание:**  
    Сервисы с этим временем жизни создаются один раз за запрос (например, HTTP-запрос в ASP.NET Core). Это удобно, когда необходимо, чтобы все компоненты, использующие один и тот же сервис в рамках одного запроса, работали с одной его копией.
    
- **Применение:**  
    Часто используется для работы с контекстами базы данных (например, `DbContext` в Entity Framework Core), где требуется единая транзакция и единый контекст для всего запроса.
    
- **Пример регистрации:**    
    
    `services.AddScoped<IOrderService, OrderService>();`
    

### 2. Singleton

- **Описание:**  
    Сервис с временем жизни Singleton создается один раз и используется на протяжении всего времени работы приложения. Это означает, что все запросы и компоненты получают одну и ту же инстанцию.
    
- **Применение:**  
    Подходит для сервисов, не зависящих от состояния или которые сами управляют своим состоянием. Например, для кеширования, логирования или работы с конфигурацией.
    
- **Пример регистрации:**
    
    csharp
    
    КопироватьРедактировать
    
    `services.AddSingleton<ILogger, ConsoleLogger>();`
    

---

## Рекомендации и нюансы

- **Выбор времени жизни:**
    
    - **Scoped:** Если сервис должен быть уникален для каждого запроса или работы, где требуется независимый контекст.
    - **Singleton:** Если сервис не содержит изменяемого состояния или это состояние контролируется и синхронизируется. Будьте осторожны с потокобезопасностью при использовании Singleton.
- **Избегайте утечек памяти:**  
    При использовании Singleton важно следить за зависимостями, которые могут ссылаться на ресурсы, требующие освобождения. Не забудьте о корректном освобождении ресурсов (реализуйте `IDisposable`, если необходимо).
    
- **Тестируемость:**  
    DI упрощает подмену зависимостей в тестах (например, внедрение mock-объектов), что повышает удобство юнит-тестирования.
    
- **Контейнеры DI:**  
    В ASP.NET Core встроен легковесный DI-контейнер, поддерживающий конструкторное внедрение и управление жизненным циклом. Для более сложных сценариев можно использовать сторонние контейнеры (Autofac, Ninject и др.), но встроенного механизма зачастую достаточно.
    

---

## Заключение

Dependency Injection позволяет создавать гибкую, масштабируемую и тестируемую архитектуру, разделяя ответственность за создание и управление зависимостями от бизнес-логики. Понимание принципов DI и грамотный выбор времени жизни (Scoped для изолированных запросов, Singleton для глобальных, неизменяемых сервисов) – ключевые моменты при проектировании современных приложений на ASP.NET Core.

## Transient

### Что это такое?

**Transient** – это время жизни, при котором каждый раз, когда запрашивается зависимость, создаётся новый экземпляр сервиса. То есть, при каждом обращении к DI-контейнеру для получения этого сервиса вы получаете свежий объект.

### Когда использовать?

- **Лёгковесные, не сохраняющие состояние сервисы:**  
    Если ваш сервис не хранит состояние между вызовами и является относительно лёгким для создания, то transient — отличный выбор.
- **Избежание нежелательного разделения состояния:**  
    При использовании transient вы гарантируете, что каждый потребитель получает свою копию сервиса, что исключает случайное совместное использование состояния между разными частями приложения.

### Пример регистрации и использования:

```C#
public interface IMyService
{
    void DoWork();
}

public class MyService : IMyService
{
    public void DoWork()
    {
        Console.WriteLine($"Выполнение работы в экземпляре: {this.GetHashCode()}");
    }
}

// Регистрация сервиса с жизненным циклом Transient
services.AddTransient<IMyService, MyService>();

```

**Использование в контроллере:**

```C#
[ApiController]
[Route("[controller]")]
public class SampleController : ControllerBase
{
    private readonly IMyService _service1;
    private readonly IMyService _service2;

    // Конструктор получает два экземпляра IMyService, каждый из которых будет новым
    public SampleController(IMyService service1, IMyService service2)
    {
        _service1 = service1;
        _service2 = service2;
    }

    [HttpGet]
    public IActionResult Get()
    {
        _service1.DoWork();
        _service2.DoWork();

        // Если transient, то _service1 и _service2 будут разными экземплярами
        return Ok(new { Service1 = _service1.GetHashCode(), Service2 = _service2.GetHashCode() });
    }
}

```

В этом примере два вызова `IMyService` в одном контроллере создадут два разных экземпляра, что можно проверить по различию их хэш-кодов.

### На что обратить внимание

- **Потенциальное увеличение нагрузки:**  
    Если сервис тяжёлый для создания или его создание сопровождается затратными операциями, частое создание экземпляров может негативно сказаться на производительности.
- **Инъекция в сервисы с другим временем жизни:**  
    Будьте внимательны, когда внедряете transient-сервисы в singleton-сервисы. При этом экземпляр transient будет создан один раз при создании singleton, что может привести к неожиданному поведению.
- **Управление ресурсами:**  
    Если transient-сервис использует ресурсы, требующие освобождения (например, реализует `IDisposable`), убедитесь, что они корректно освобождаются.

---

## Итог

- **Transient:** Создаёт новый экземпляр каждый раз при запросе.
- **Scoped:** Создаёт один экземпляр на каждый запрос (или иной скоуп).
- **Singleton:** Создаёт один экземпляр на всё время работы приложения.