Command Query Responsibility Segregation

CQRS — это паттерн проектирования, который разделяет логику чтения (Query) и записи (Command) в приложении. Этот паттерн помогает улучшить масштабируемость и производительность, а также позволяет более гибко управлять сложными приложениями, где чтение и запись данных требуют разных подходов. В отличие от традиционного подхода, где операции чтения и записи обрабатываются одним и тем же слоем (например, в одном сервисе или репозитории), CQRS предполагает разделение этих операций на два отдельных слоя.

### Основные принципы CQRS

1. **Command** — отвечает за изменения состояния системы (например, создание, обновление или удаление данных). Команды не возвращают данных, только статус выполнения (например, успех или ошибка).
2. **Query** — отвечает за извлечение данных. Эти запросы могут быть сложными, но они не изменяют состояние системы.

### Как это работает в ASP.NET Core

В приложении, использующем CQRS, можно выделить два основных компонента:

- **Command Handler** — обработчик команд.
- **Query Handler** — обработчик запросов.

Каждый из этих обработчиков реализует логику, связанную с командой или запросом, и взаимодействует с соответствующими источниками данных.

### Пример структуры проекта с использованием CQRS:

1. **Команды (Commands):** Объекты, представляющие команды, например, добавление пользователя, обновление заказа.
2. **Запросы (Queries):** Объекты, представляющие запросы для получения данных, например, получение всех пользователей или получение заказа по ID.
3. **Обработчики команд (Command Handlers):** Логика обработки команд.
4. **Обработчики запросов (Query Handlers):** Логика обработки запросов.
5. **Слой данных:** Хранение данных, часто используется репозиторий, который может быть разделён на репозитории для команд и для запросов.

### Когда рекомендуется использовать CQRS:

- **Высокая нагрузка и сложность**: Когда приложение имеет сложную бизнес-логику, которая сильно различается между операциями чтения и записи, CQRS может быть полезным для упрощения и разделения этих процессов.
- **Масштабируемость**: CQRS помогает легко масштабировать приложение, позволяя отдельно масштабировать части, отвечающие за запись и чтение.
- **Частые изменения в данных**: Когда структура данных меняется часто, и нужно гибко подходить к запросам и их обработке.
- **Требования к высокой производительности**: В случае, если запросы и команды требуют разных подходов для оптимизации производительности (например, сложные запросы на чтение и простые на запись).

### Когда не рекомендуется применять CQRS:

- **Простые приложения**: Если приложение не требует сложной логики или высокой производительности, применение CQRS может привести к излишней сложности.
- **Маленькие проекты**: В небольших проектах с ограниченными требованиями CQRS может быть перегрузкой, поскольку добавляется излишняя архитектурная сложность.
- **Невозможность разделить чтение и запись**: Если операции чтения и записи тесно связаны и сложно их разделить, CQRS может быть нецелесообразен.

### Применение CQRS с другими паттернами и технологиями

6. **Event Sourcing**: CQRS часто используется вместе с паттерном Event Sourcing, где все изменения состояния сохраняются как события, и состояние восстанавливается на основе этих событий. Это позволяет создавать системы с точным отслеживанием изменений.
7. **Mediator Pattern**: В сочетании с паттерном Mediator (например, библиотека [MediatR](https://github.com/jbogard/MediatR)), чтобы передавать запросы и команды через центральный объект, который делегирует их соответствующим обработчикам.
8. **Microservices**: В микросервисной архитектуре CQRS помогает разделить логику между сервисами, что позволяет масштабировать и разрабатывать их независимо.

### Пример реализации CQRS в ASP.NET Core

Для примера используем библиотеку **MediatR**, которая помогает организовать обработку команд и запросов.

#### Шаги для реализации CQRS с MediatR:

9. **Добавьте NuGet-пакет:**
    
```sh
dotnet add package MediatR

```
    
10. **Создайте команду (Command):** Команда представляет собой объект, который содержит данные для выполнения действия, но не возвращает данные.
    
```C#
public class CreateUserCommand : IRequest<Guid>
{
    public string Name { get; set; }
    public string Email { get; set; }
}

```
    
11. **Создайте обработчик команды (Command Handler):** Обработчик будет отвечать за выполнение команды.
    
```C#
public class CreateUserCommandHandler : IRequestHandler<CreateUserCommand, Guid>
{
    private readonly IUserRepository _userRepository;

    public CreateUserCommandHandler(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public async Task<Guid> Handle(CreateUserCommand request, CancellationToken cancellationToken)
    {
        var user = new User
        {
            Name = request.Name,
            Email = request.Email
        };

        await _userRepository.AddUserAsync(user);
        return user.Id;
    }
}

```
    
12. **Создайте запрос (Query):** Запрос используется для получения данных.
    
```C#
public class GetUserByIdQuery : IRequest<User>
{
    public Guid Id { get; set; }
}

```
    
13. **Создайте обработчик запроса (Query Handler):** Обработчик будет отвечать за выполнение запроса.
    
```C#
public class GetUserByIdQueryHandler : IRequestHandler<GetUserByIdQuery, User>
{
    private readonly IUserRepository _userRepository;

    public GetUserByIdQueryHandler(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public async Task<User> Handle(GetUserByIdQuery request, CancellationToken cancellationToken)
    {
        return await _userRepository.GetUserByIdAsync(request.Id);
    }
}

```
    
14. **Настройка MediatR в `Startup.cs`:** Для использования MediatR нужно зарегистрировать его в контейнере зависимостей:
    
```C#
public void ConfigureServices(IServiceCollection services)
{
    services.AddMediatR(Assembly.GetExecutingAssembly());
    // другие сервисы
}

```
    
15. **Вызов команды или запроса:** Пример использования команды и запроса в контроллере.
    
```C#
public class UserController : ControllerBase
{
    private readonly IMediator _mediator;

    public UserController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserCommand command)
    {
        var userId = await _mediator.Send(command);
        return CreatedAtAction(nameof(GetUserById), new { id = userId }, null);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUserById(Guid id)
    {
        var query = new GetUserByIdQuery { Id = id };
        var user = await _mediator.Send(query);
        return user == null ? NotFound() : Ok(user);
    }
}

```
    

### Лучшие практики при использовании CQRS:

16. **Использование MediatR или аналогичных библиотек**: Библиотеки, такие как MediatR, помогают централизовать обработку команд и запросов, что упрощает тестирование и поддержку кода.
17. **Четкое разделение запросов и команд**: Не смешивайте операции, которые изменяют данные, и операции, которые их читают. Это поможет поддерживать более чистую архитектуру.
18. **Обработка ошибок**: Используйте стратегию обработки ошибок на уровне команд и запросов, чтобы централизовать логику обработки ошибок.
19. **Асинхронность**: Для команд и запросов, которые выполняют длительные операции (например, доступ к базе данных), используйте асинхронные методы.
20. **Event Sourcing**: Если ваше приложение требует точного отслеживания изменений состояния, используйте CQRS в сочетании с Event Sourcing для хранения всех изменений в виде событий.

### Заключение:

CQRS — это мощный паттерн для сложных приложений, который помогает разделить операции чтения и записи, улучшить производительность и масштабируемость. Однако его применение требует внимательности и должно быть обоснованным, особенно для простых приложений, где дополнительная сложность может быть избыточной. Правильное использование CQRS в сочетании с такими паттернами, как MediatR и Event Sourcing, может значительно улучшить структуру приложения и облегчить поддержку.