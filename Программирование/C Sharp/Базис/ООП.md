Объектно-Ориентированное Программирование (ООП) — это парадигма, в которой программа строится на основе объектов, объединяющих данные (состояние) и поведение (методы). В C# ООП лежит в основе языка и помогает создавать гибкие, расширяемые и поддерживаемые приложения. Ключевые принципы ООП:

1. **Классы**
2. **Наследование**
3. **Полиморфизм**
4. **Инкапсуляция**
5. **Абстракция**
## Классы

**Класс** – это шаблон для создания объектов, определяющий свойства (данные) и методы (поведение), которыми будет обладать объект.
### Пример:

```C#
public class Person
{
    // Поля (обычно объявляются как private для защиты данных)
    private string firstName;
    private string lastName;

    // Свойства для доступа к полям (инкапсуляция)
    public string FirstName
    {
        get { return firstName; } 
        set { firstName = value; }
    }
    public string LastName
    {
        get { return lastName; }
        set { lastName = value; }
    }

    // Конструктор
    public Person(string firstName, string lastName)
    {
        this.firstName = firstName; // лучше создавать 
        this.lastName = lastName;
    }

    // Метод
    public void Greet()
    {
        Console.WriteLine($"Привет, меня зовут {firstName} {lastName}.");
    }
}
```

**Пояснение:**

- **Поля**: хранят данные, здесь `firstName` и `lastName`.
- **Свойства**: обеспечивают контроль доступа к полям.
- **Конструктор**: инициализирует объект при создании.
- **Метод**: описывает поведение объекта.

## Наследование

**Наследование** позволяет создавать новый класс на основе существующего. Производный (наследующий) класс получает все члены базового класса и может расширять или модифицировать их поведение.
### Пример:

```C#
// Базовый класс
public class Animal
{
    public string Name { get; set; }

    public Animal(string name)
    {
        Name = name;
    }

    // Виртуальный метод, который можно переопределить в наследниках
    public virtual void Speak()
    {
        Console.WriteLine("Животное издает звук.");
    }
}

// Производный класс
public class Dog : Animal
{
    public Dog(string name) : base(name) { }

    // Переопределение метода Speak
    public override void Speak()
    {
        Console.WriteLine($"{Name} лает: Гав-гав!");
    }
}
```

**Пояснение:**

- Класс `Dog` наследует от `Animal` с помощью ключевого слова `: Animal`.
- Метод `Speak()` объявлен как `virtual` в базовом классе и переопределён с помощью `override` в производном классе.

## Полиморфизм

**Полиморфизм** позволяет использовать объекты производных классов через ссылки базового класса, что даёт возможность вызывать переопределённые методы, соответствующие фактическому типу объекта.
### Пример:

```C#
public class Program
{
    public static void Main(string[] args)
    {
        Animal genericAnimal = new Animal("Некоторое животное");
        Animal myDog = new Dog("Шарик");

        // Вызов метода Speak() демонстрирует полиморфизм:
        genericAnimal.Speak();  // Выведет: "Животное издает звук."
        myDog.Speak();          // Выведет: "Шарик лает: Гав-гав!"
    }
}
```

**Пояснение:**

- Несмотря на то, что `myDog` имеет тип `Animal`, при вызове `Speak()` выполняется метод, переопределённый в классе `Dog`.

## Инкапсуляция

**Инкапсуляция** — это сокрытие внутреннего состояния объекта и предоставление доступа к нему только через публичные методы или свойства. Это защищает данные от некорректного использования и позволяет изменять внутреннюю реализацию, не затрагивая внешний интерфейс.
### Пример:

```C#
public class BankAccount
{
    // Закрытое поле, недоступное напрямую извне
    private decimal balance;

    // Свойство для чтения баланса
    public decimal Balance
    {
        get { return balance; }
    }

    // Метод для внесения депозита
    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
        else
        {
            throw new ArgumentException("Сумма должна быть положительной.");
        }
    }

    // Метод для снятия средств
    public void Withdraw(decimal amount)
    {
        if (amount > 0 && amount <= balance)
        {
            balance -= amount;
        }
        else
        {
            throw new ArgumentException("Недостаточно средств или неверная сумма.");
        }
    }
}

```

**Пояснение:**

- Поле `balance` скрыто (private).
- Доступ к балансу возможен только через публичное свойство и методы, которые контролируют корректность операций.

## Абстракция

**Абстракция** позволяет выделить существенные характеристики объекта, скрывая детали реализации. В C# это реализуется через абстрактные классы и интерфейсы.
### Абстрактный класс:

```C#
// Абстрактный класс, который не может быть создан напрямую
public abstract class Shape
{
    // Абстрактный метод, обязательный для реализации в наследниках
    public abstract double GetArea();
}

// Конкретный класс-наследник
public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius)
    {
        Radius = radius;
    }

    // Реализация абстрактного метода
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
}
```

### Интерфейс:

```C#
// Интерфейс определяет контракт (набор методов и свойств)
public interface IMovable
{
    void Move(double deltaX, double deltaY);
}

// Класс, реализующий интерфейс
public class Car : IMovable
{
    public double X { get; private set; }
    public double Y { get; private set; }

    public Car(double x, double y)
    {
        X = x;
        Y = y;
    }

    public void Move(double deltaX, double deltaY)
    {
        X += deltaX;
        Y += deltaY;
        Console.WriteLine($"Машина перемещена в точку ({X}, {Y}).");
    }
}

```

**Пояснение:**

- **Абстрактные классы**: Позволяют определить общие черты для группы классов, при этом сами не могут быть инстанцированы. Они могут содержать как реализованные, так и абстрактные члены.
- **Интерфейсы**: Определяют контракт, который обязан соблюдать класс, реализующий этот интерфейс. Это обеспечивает гибкость и возможность множественного наследования по контракту.