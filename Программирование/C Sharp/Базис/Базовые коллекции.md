В .NET коллекции делятся на две большие группы:

- **Non-generic коллекции** (например, `ArrayList`, `Hashtable`, `SortedList` из пространства имён `System.Collections`), где элементы хранятся как `object`. Такие коллекции требуют кастинга, не обеспечивают безопасность типов и могут приводить к дополнительным накладным расходам (боксинг/анбоксинг для значимых типов).

- **Generic коллекции** (например, `List<T>`, `Dictionary<TKey, TValue>`, `HashSet<T>` из пространства имён `System.Collections.Generic`), которые обеспечивают безопасность типов на этапе компиляции, не требуют лишних преобразований и, как правило, работают быстрее.

Кроме рассмотренных выше, в .NET есть и другие Generic коллекции:

- **`Stack<T>`** и **`Queue<T>`** – для работы с принципами LIFO и FIFO соответственно.
- **`LinkedList<T>`** – двусвязный список.
- **`SortedList<TKey, TValue>`**, **`SortedDictionary<TKey, TValue>`** – для хранения упорядоченных пар ключ-значение.
- **`ConcurrentDictionary<TKey, TValue>`** и другие коллекции в пространстве имен `System.Collections.Concurrent` – для многопоточной работы.
## `List<T>`

**`List<T>`** реализует интерфейсы:
- `IList<T>`
- `ICollection<T>`
- `IEnumerable<T>`
- А также их не-Generic версии через явную реализацию (например, `IList`, `ICollection`, `IEnumerable`).
### Принцип работы

`List<T>` реализует **динамический массив**. Это означает, что:

- Элементы хранятся во внутреннем массиве.
- При добавлении нового элемента, если текущая вместимость недостаточна, массив автоматически расширяется (обычно происходит **экспоненциальное увеличение** – например, удвоение размера). Это обеспечивает амортизированную сложность вставки в конец списка за **O(1)**.
- Доступ по индексу осуществляется за **O(1)**.
### Пример использования

```C#
// Создаем список целых чисел
List<int> numbers = new List<int> { 1, 2, 3, 4 };

// Добавление элемента
numbers.Add(5);

// Доступ по индексу
Console.WriteLine(numbers[0]); // Выведет 1

// Перебор элементов
foreach (int num in numbers)
{
    Console.WriteLine(num);
}
```
### Плюсы и Минусы

**Плюсы:**
- Быстрый доступ по индексу.
- Автоматическое управление размером.
- Хорошая производительность при последовательном добавлении элементов.

**Минусы:**
- Вставка или удаление элемента в середине списка требует сдвига элементов – **O(n)**.
- Избыточное потребление памяти, если вместимость значительно превышает фактическое количество элементов.
## Dictionary<TKey, TValue>

**Dictionary<TKey, TValue>** реализует:
- `IDictionary<TKey, TValue>`
- `ICollection<KeyValuePair<TKey, TValue>>`
- `IEnumerable<KeyValuePair<TKey, TValue>>`
- А также не-Generic интерфейсы `IDictionary`, `ICollection` и `IEnumerable`.
### Принцип работы

`Dictionary<TKey, TValue>` представляет собой **хэш-таблицу**:

- Каждая пара «ключ-значение» сохраняется в так называемых «бакетах» (корзинах) на основе значения хэш-функции ключа.
- Для корректной работы требуется, чтобы тип ключа корректно реализовывал методы `GetHashCode()` и `Equals()`.
- **Операции поиска, добавления и удаления** в среднем работают за **O(1)**, но в худшем случае (при большом количестве коллизий) – за **O(n)**.
- При достижении определённого коэффициента заполнения происходит **rehash** – перераспределение элементов в новую, более большую, таблицу.
### Пример использования

```C#
// Создаем словарь, где ключ – строка, значение – целое число
Dictionary<string, int> ages = new Dictionary<string, int>();

ages.Add("Alice", 30);
ages.Add("Bob", 25);

// Получение значения по ключу
if (ages.TryGetValue("Alice", out int aliceAge))
{
    Console.WriteLine($"Alice is {aliceAge} years old.");
}

// Перебор элементов словаря
foreach (KeyValuePair<string, int> entry in ages)
{
    Console.WriteLine($"{entry.Key}: {entry.Value}");
}
```
### Внутренние алгоритмы и паттерны

- **Хеширование и распределение по бакетам.** При добавлении элемента вычисляется хэш-код ключа, после чего элемент помещается в соответствующий бакет.
- **Рехеширование.** При превышении определённого порога заполнения внутренний массив расширяется, а элементы перераспределяются.
- **Использование цепочек или открытой адресации.** В реализации Dictionary используется массив структур (записей) с индексами для формирования цепочки в бакете.
### Плюсы и Минусы

**Плюсы:**
- Очень быстрый доступ по ключу.
- Гибкость – можно использовать практически любые типы в качестве ключей (при корректной реализации `GetHashCode` и `Equals`).

**Минусы:**
- Не сохраняет порядок элементов.
- Потребляет дополнительную память для организации бакетов и ведения внутренних структур.
- При большом количестве коллизий может снизиться производительность.
## `HashSet<T>`

**`HashSet<T>`** реализует:
- `ISet<T>`
- `ICollection<T>`
- `IEnumerable<T>`
- `IReadOnlyCollection<T>`
### Принцип работы

`HashSet<T>` – это коллекция, которая хранит **уникальные элементы** и реализована с использованием хэш-таблицы, похожей на Dictionary, но без привязки к значению:
- Использует хэширование для быстрого поиска, добавления и удаления элементов (средняя сложность **O(1)**).
- Автоматически предотвращает дублирование элементов.
- Поддерживает стандартные операции над множествами: объединение, пересечение, разность и симметрическую разность.
### Пример использования

```C#
// Создаем HashSet целых чисел
HashSet<int> uniqueNumbers = new HashSet<int> { 1, 2, 3 };

// Попытка добавить повторяющееся значение вернет false
bool added = uniqueNumbers.Add(2); // added будет false

// Проверка наличия элемента
if (uniqueNumbers.Contains(3))
{
    Console.WriteLine("Элемент 3 присутствует.");
}

// Перебор элементов
foreach (int num in uniqueNumbers)
{
    Console.WriteLine(num);
}
```
### Внутренние алгоритмы и паттерны

- **Хеширование.** Используется для вычисления индекса бакета для каждого элемента.
- **Рехеширование.** Аналогично Dictionary, при превышении порога заполнения происходит перераспределение элементов.
- Операции над множествами реализованы с учетом особенностей хэш-таблицы для обеспечения высокой производительности.
### Плюсы и Минусы

**Плюсы:**
- Быстрый поиск и проверка наличия элемента.
- Автоматически обеспечивает уникальность значений.
- Удобен для выполнения операций над множествами.

**Минусы:**
- Элементы неупорядоченные.
- При плохой реализации хэш-функции может наблюдаться снижение производительности.
## Generic vs. Non-Generic коллекции

### Generic коллекции

- **Типобезопасность.** Элементы имеют фиксированный тип, что обнаруживается на этапе компиляции.
- **Производительность.** Отсутствие упаковки (boxing) для значимых типов.
- **Удобство.** Нет необходимости в постоянном приведении типов.
### Non-Generic коллекции

- Хранят элементы как `object`.
- Требуется явное приведение типов, что может привести к ошибкам во время выполнения.
- Часто сопряжены с дополнительными затратами на упаковку/распаковку значимых типов.
- Примеры: `ArrayList`, `Hashtable`.

Рекомендуется использовать Generic коллекции, при прочих равных.
## Внутренние алгоритмы и паттерны в коллекциях

- **Динамическое расширение массива (`List<T>`):** При добавлении элемента, если внутренний массив заполнен, происходит создание нового массива с увеличенной вместимостью (обычно в 2 раза) и копирование элементов в него.
- **Хеш-таблица (Dictionary и HashSet):**
    - **Хеширование:** Вычисление хэш-кода для определения бакета.
    - **Обработка коллизий:** Использование цепочек (списки записей) для хранения нескольких элементов с одинаковым бакетом.
    - **Рехеширование:** При достижении порога заполнения происходит перераспределение элементов в больший массив бакетов.
- **Алгоритмы поиска:**
    - Для **`List<T>`** – простой доступ по индексу или линейный перебор при поиске элемента.
    - Для **`Dictionary`** – поиск осуществляется по хеш-коду с дополнительной проверкой равенства.
    - Для **`HashSet<T>`** – аналогично Dictionary, но с проверкой только ключа (значения).

## Сводное сравнение различных коллекций

| Коллекция                      | Плюсы                                                                                                        | Минусы                                                                        |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------- |
| **`List<T>`**                  | Быстрый доступ по индексу O(1)<br>Динамическое изменение размера                                             | Вставка/удаление в середине – O(n)  <br>Возможное перераспределение памяти    |
| **`Dictionary<TKey, TValue>`** | Быстрый доступ по ключу (средняя O(1))  <br>Гибкость в использовании ключей                                  | Неупорядоченность  <br>Дополнительная память для бакетов и обработки коллизий |
| **`HashSet<T>`**               | Быстрая проверка наличия элемента  <br>Гарантированная уникальность  <br>Удобен для операций над множествами | Неупорядоченность  <br>Зависимость от качества хэш-функции                    |
