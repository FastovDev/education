Сборщик мусора необходим для эффективного управления памятью. Его работа практически всегда автоматизирована и направлена на максимально эффективную очистку памяти с минимальной нагрузкой по времени и работой с самой памятью.

Сборщик мусора направлен на автоматическую работу по очистке памяти, освобождая время разработки от необходимости вручную отслеживать состояние памяти, потребляемой приложением на компьютере.

Сборщик мусора самостоятельно оценивает расположение объектов в управляемой куче (выделенном участке памяти для приложения) и эффективно размещает их в этой куче (старается разместить всю память в неразрывном виде для увеличения скорости обработки памяти, удаляет старые объекты, сжимает область используемой памяти - смотреть стадии сборки). 

Объекты, которые больше не используются в приложении удаляются, а выделенные под них участки памяти очищаются и остаются доступны для будущих распределений. Объекты, размещенные в управляемой куче автоматически получают чистое содержимое, что позволяет проводить инициализацию без передачи в конструктор каждого поля данных. 

Обеспечивает безопасность памяти таким образом, что новые объекты не могут использовать память, выделенную под другие объекты.

При инициализации нового процесса происходит выделение непрерывного участка адресного пространства памяти. Именно такое пространство называется управляемой кучей. Все ссылочные типы размещаются в этом участке памяти. Первая ссылка выделяется на базовый адрес кучи (начало адресного пространства). Следующая ссылка будет размещена непосредственно за первой. Такой механизм будет работать пока не закончится выделенное пространство. Благодаря тому, что в управляемой куче всегда известен последний адрес выделенной памяти, то добавление новых объектов происходит быстро, на уровне добавления объекта в стек. Также, благодаря этому происходит и быстрое чтение данных в управляемой куче. 

Момент необходимости освобождения памяти зависит от оценки произведенного выделения памяти. Используя корни приложения (ссылки на объекты в управляемой куче), GC  определяет какие участки памяти больше не используются в работе приложения. Для этого, на основании корней приложения, создается граф, содержащий все объекты, к которым можно получить доступ из корней. 

Также в процессе освобождения ресурсов через функцию копирования памяти происходит уплотнение достижимых объектов, чтобы избежать фрагментации данных в памяти, обновляет в корнях ссылки на новое положение объектов и обновляет адресный указатель последнего достижимого объекта. Но процесс сжатия данных запускается не всегда, а только если GC решил, что кол-во недостижимых объектов достаточно велико для такой задачи. Аналогично если после сборки мусора все объекты в управляемой куче остаются на месте, задача по уплотнению запущена не будет. 

Все объекты, которые имеют вес более 85кб являются большими объектами и хранятся в отдельной куче больших объектов (Large Object Heap - LOH). Сборщик мусора автоматически удаляет такие объекты, если они больше не нужны, однако обычно стадию дефрагментации выделенной под большие объекты памяти не запускает, так как сжатие больших объектов дорого по времени и ресурсам. Тем не менее используя свойство GCSettings.LargeObjectHeapCompactionMode можно указать сборщику, что необходимо сжимать LOH при следующей полной блокирующей сборке мусора. Аналогично сжатие LOH может запуститься, если все поколения сборки мусора уже были сжаты, LOH фрагментирован, а необходимой чистой памяти для работы приложения по-прежнему не хватает. 