В C# сборка мусора имеет 3 поколения ( 0,1,2). 
Алгоритм сборки и кол-во поколений определились в процессе экспериментов со схемами сборки мусора и строится на ряде обобщений.

Одно из них - делать сборку мусора на части управляемой кучи быстрее, чем по всей куче. 
Второе - более новые объекты зачастую имеют короткий срок жизни, а старые объекты - более долгий срок жизни. 
Третье - новые объекты зачастую связаны друг с другом более плотно, и поэтому обращение к ним происходит приблизительно в одно время. 

Все новые объекты попадают в поколение 0. Если объект остается после следующей сборки мусора 0 поколения, то он перемещает в 1 поколение. Не всегда 1 поколение будет задействовано в сборке мусора, но если после прохода по 1 поколению объект остается жив - то он попадает во 2 поколение. Еще реже происходит проход по 2 поколению, так же называемый полной сборкой мусора. Объекты, оставшиеся в живых после сборки 2 поколения остаются во втором поколении. 

Частым инициатором прохода по поколению с целью сборки мусора является индикатор заполненности поколения. Когда в поколении не хватает памяти на выделение нового объекта, то запускается сборка мусора. Начинается это с 0 поколения. Если после очистки поколения чистой памяти достаточно для выделения объекта, то выжившие объекты 0 уровня проходит процедуру сжатия и перемещаются в 1 поколение, но сборки по нему не происходит. 

Автоматическая очистка мусора и работа GC происходит только с управляемой кучей. Для управление памятью в неуправляемой куче необходимо явное освобождение ресурсов. Зачастую такими объектами являются различные обертки на ресурсами операционной системы, такие как дескриптор файла, окна или  сетевого подключения. Все что может сделать сборщик это отследить время жизни обертки, но как очищать используемые под ней ресурсы он не знает. Для явной очистки таких ресурсов рекомендуется использовать метод Dispose, в котором будет находиться код очищающий ссылки на использование ресурсов. 