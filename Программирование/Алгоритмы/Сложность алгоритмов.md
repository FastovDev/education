О большое отвечает за время выполнения алгоритма
Сложность алгоритма определяется по количеству операций необходимых для его выполнения
Существует 7 основных стандартных оценок сложности алгоритмов:
<h3>O (1) (постоянной сложности)</h3> 
O (1) - данный тип нотации подразумевает что скорость выполнения алгоритма и выделения памяти не меняется с увеличением n. 
В качестве примера может быть алгоритма обращающийся к конкретному элементу массива. Какой бы не был размер массива, обращение по индексу вернет и обработает единичный элемент указанного индекса.
![[Pasted image 20240704172013.png]]
<h3>O (log n) (логарифмическая сложность)</h3> 
O (log n) - по умолчанию степень логарифма равна двойке, таким образом мы получаем количество операций на выполнение алгоритма равное округлению корня от N в большую сторону. 
Таким образом O(log 5) = sqrt 5 , что дает значение больше 2 и меньше 3. Округление в большую сторону дает 3 операции. 
Такая сложность алгоритма называется логарифмической и описывает логарифмическое время выполнения операции.
Пример алгоритма сортировки - бинарный поиск.
В целом данная сложность характерна для рекурсивных алгоритмов.

![[Pasted image 20240704172100.png]]

![[Pasted image 20240704172114.png]]
<h3>O (n) (линейная сложность)</h3>
O (n) - линейное время выполнения алгоритма. 
Таким образом O(5) = 5  операций. 
Увеличение размерности на n приводит к увеличению количества операций на n.
Пример алгоритма сортировки - простой поиск перебором.

![[Pasted image 20240704172131.png]]

![[Pasted image 20240704172138.png]]
<h3>O (n * log n) (логлинейная сложность)</h3>
O (n * log n) - означает что размерность n будет выполнена n раз по log(n). 
Данный уровень сложности часто встречается в рекурсивных алгоритмах сортировки или при алгоритме сортировки двоичных деревьев. Встречается редко.

![[Pasted image 20240704172217.png]]

<h3>O (n^x) (полиномиальная сложность)</h3>
O (n^x) - не самая эффективная сложность алгоритма. Этот и последующие уровни сложности могут указывать на то, что код требует рефакторинга.  
В зависимости от x показывает сколько раз будет выполнено n по n операций.
Так вложенный цикл для создания матрицы будет представлять собой линейный алгоритм. Но если мы используем вложенный цикл без опоры на предыдущий, например просматривает все пространство двумерного массива n раз в поисках нужного числа, то как раз получаем полиномиальную сложность.

![[Pasted image 20240704172246.png]]
<h3>O (x^n) (экспоненциальная сложность)</h3>
O (x^n) - часто получается из-за наличия рекурсивного алгоритма, который вызывает x алгоритмов с n-1. 
Следует избегать таких алгоритмов максимально возможно.
Алгоритм ханойской башни - известный пример такого алгоритма. Здесь n = 2.
В стандартной разработке ПО почти не встречается, может встретиться при использовании арифметической модели вычислений или при использовании машин Тьюринга. 

![[Pasted image 20240704172329.png]]

<h3>O (n!) (факториальная сложность)</h3>
O (n!) - самый не эффективный алгоритм из стандартных. 
Обычно встречается при попытке посчитать все возможные комбинации какого-то определенного пространства. 
Так, наличие всевозможных комбинаций колоды карт составит 52 факториала. 
Типичным примером в программировании такой сложности выступает решение задачи коммивояжера с помощью грубой силы, то есть простого перебора. 

Таким образом O(log 5) = sqrt 5 , что дает значение больше 2 и меньше 3. Округление в большую сторону дает 3 операции. 
Такая сложность алгоритма называется логарифмической и описывает логарифмическое время выполнения операции.

![[Pasted image 20240704172858.png]]