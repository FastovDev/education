#### DDL

Создание таблицы:
```
CREATE TABLE courses ( 
	course_no varchar(30), 
	title text NOT NULL, 
	credits integer, 
	CONSTRAINT course_pkey PRIMARY KEY (course_no) 
);
```

Удаление таблицы:
```
DROP TABLE courses
```

Изменение таблицы:
```
CREATE TABLE courses ( 
	course_no varchar(30), 
	title text NOT NULL, 
	credits integer, 
	CONSTRAINT course_pkey PRIMARY KEY (course_no) 
);
```

Ограничения целостности:
- NOT NULL - запрещает неопределенное значение атрибута.
- UNIQUE - обычно ставится на возможный ключ, запрещает дубликаты. Допускается значение NULL, при необходимости.
- PRIMARY KEY - задает первичный ключ. NULL запрещен. 
- FOREIGN KEY - задает связи между отношениями, указывая ссылку с атрибута или группы атрибутов на первичный или уникальный ключ в другом отношении. 
- CHECK - задает произвольное условие на значения атрибута в кортеже.

Существует возможность выполнять DDL запрос по условию существования. Для команд удаления и изменения таблицы `IF EXISTS`, для команды создания таблицы `IF NOT EXIST`. Данные команды будут выполнять в первом случае если таблицы с названием, указанным в запросе уже существуют, а во втором - если не существует. 
#### DML

##### INSERT INTO
Добавление новых строк в таблицу:
```
INSERT INTO courses (course_no, title, credits) 
VALUES ('CS301', 'Базы данных', 5);
```
В этой команде не важно, в каком порядке мы будет указывать столбцы, имеющиеся в таблице, но важно, чтобы порядок добавляемых значений соответствовал тому же порядку, в котором мы перечисляли столбцы. 
Если столбцы могут содержать значение NULL, или имеют установленное значение по умолчанию, то мы можем не указывать эти столбцы, они заполнятся автоматически. 

Кроме того, мы можем вообще не указывать столбцы, но тогда порядок заполняемых значений должен точно соответствовать схеме таблицы. Это делает запрос очень зависимым от возможного изменения схемы таблицы. 

Если вдруг добавляемые значения вызывают ошибку из-за существующих ограничений целостности, то будет выдаваться ошибка. Мы можем задать поведение запроса, вместо ошибки, если возникает конфликт. Например, мы можем ничего не делать. Или по первичному ключу изменить данные, если такой первичный ключ уже существует. 

`ON CONFLICT DO NOTHING`

Примеры:
```
INSERT INTO distributors (did, dname) VALUES
	(5, 'Gizmo Transglobal'), 
	(6, 'Associated Computing, Inc')
ON CONFLICT (did) DO UPDATE 
SET dname = EXCLUDED.dname;
```

В данном примере предполагается, что определён уникальный индекс, ограничивающий значения в столбце `did`:

```
INSERT INTO distributors (did, dname) VALUES 
	(7, 'Redline GmbH')
ON CONFLICT (did) DO NOTHING;
```

Предложение `WHERE` позволяет ограничить набор фактически изменяемых строк (однако любая существующая строка, не подлежащая изменению, всё же будет заблокирована):
```
-- Не менять данные существующих дистрибьюторов в зависимости от почтового индекса
INSERT INTO distributors AS d (did, dname) VALUES 
	(8, 'Anvil Distribution')
ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode <> '21201';
```

```
-- Указать имя ограничения непосредственно в операторе (связанный индекс применяется для принятия решения о выполнении действия DO NOTHING)
INSERT INTO distributors (did, dname) VALUES 
	(9, 'Antwerp Design')
ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
```

```

-- Этот оператор может выбрать частичный уникальный индекс по "did" с предикатом "WHERE is_active", а может и просто использовать обычное ограничение уникальности по столбцу "did"
INSERT INTO distributors (did, dname) VALUES 
	(10, 'Conrad International')
ON CONFLICT (did) WHERE is_active DO NOTHING;
```

##### SELECT
Команда нужна для чтения данных. Любое чтение будет включать эту команду.
Базовый вариант состоит из указания команды, списка столбцов, ключевого слова FROM и имени отношения из которого осуществляется выборка. Если вместо столбцов мы укажем `*`, это означает, что мы делаем выборку всех столбцов.

`SELECT * FROM courses`

Если мы хотим отфильтровать выборку данных, мы можем добавить команду WHERE, которая за счет указания логического выражения, функций с логическим значением или операций сравнения поможет сократить общую выборку. 
```
SELECT title, credits 
FROM courses 
WHERE credits > 8
```
Атрибуты, участвующие в блоке условий не обязательны для выборки данных. 

`SELECT DISTINCT` - обычно подразумевается, что в запросе `SELECT` есть параметр `ALL`, который делает полную выборку данных, включая дубликаты. Если использовать слово `DISTINCT`, то мы заменяем полную выборку на выборку только уникальных значений, исключая дубликаты.  
##### UPDATE 
Оператор для обновления данных в таблице. 
Пример:
```
UPDATE courses 
SET credits = credits + 1 
WHERE course_no = 'CS305';
```

Без параметра WHERE обновление затронет все строки таблицы.
##### DELETE
Оператор удаления данных. 
Пример:
```
DELETE FROM courses 
WHERE course_no = 'CS305';
```
Без параметра WHERE удаление затронет все строки таблицы.

##### RETURNING
Иногда возникает необходимость получить набор данных, который был затронут нашими запросами, что актуально для операций вставки, удаления и обновления. 

В результате применения следующего скрипта мы получим строку с уже измененным значением в результате работы скрипта

```
UPDATE courses 
SET credits = 12 
WHERE course_no = 'CS305' 
RETURNING *;
```

