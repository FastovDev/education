#### DDL

Создание таблицы:
```
CREATE TABLE courses ( 
	course_no varchar(30), 
	title text NOT NULL, 
	credits integer, 
	CONSTRAINT course_pkey PRIMARY KEY (course_no) 
);
```

Удаление таблицы:
```
DROP TABLE courses
```

Изменение таблицы:
```
CREATE TABLE courses ( 
	course_no varchar(30), 
	title text NOT NULL, 
	credits integer, 
	CONSTRAINT course_pkey PRIMARY KEY (course_no) 
);
```

Ограничения целостности:
- NOT NULL - запрещает неопределенное значение атрибута.
- UNIQUE - обычно ставится на возможный ключ, запрещает дубликаты. Допускается значение NULL, при необходимости.
- PRIMARY KEY - задает первичный ключ. NULL запрещен. 
- FOREIGN KEY - задает связи между отношениями, указывая ссылку с атрибута или группы атрибутов на первичный или уникальный ключ в другом отношении. 
- CHECK - задает произвольное условие на значения атрибута в кортеже.

Существует возможность выполнять DDL запрос по условию существования. Для команд удаления и изменения таблицы `IF EXISTS`, для команды создания таблицы `IF NOT EXIST`. Данные команды будут выполнять в первом случае если таблицы с названием, указанным в запросе уже существуют, а во втором - если не существует. 
#### DML

##### INSERT INTO
Добавление новых строк в таблицу:
```
INSERT INTO courses (course_no, title, credits) 
VALUES ('CS301', 'Базы данных', 5);
```
В этой команде не важно, в каком порядке мы будет указывать столбцы, имеющиеся в таблице, но важно, чтобы порядок добавляемых значений соответствовал тому же порядку, в котором мы перечисляли столбцы. 
Если столбцы могут содержать значение NULL, или имеют установленное значение по умолчанию, то мы можем не указывать эти столбцы, они заполнятся автоматически. 

Кроме того, мы можем вообще не указывать столбцы, но тогда порядок заполняемых значений должен точно соответствовать схеме таблицы. Это делает запрос очень зависимым от возможного изменения схемы таблицы. 

Если вдруг добавляемые значения вызывают ошибку из-за существующих ограничений целостности, то будет выдаваться ошибка. Мы можем задать поведение запроса, вместо ошибки, если возникает конфликт. Например, мы можем ничего не делать. Или по первичному ключу изменить данные, если такой первичный ключ уже существует. 

`ON CONFLICT DO NOTHING`

Примеры:
```
INSERT INTO distributors (did, dname) VALUES
	(5, 'Gizmo Transglobal'), 
	(6, 'Associated Computing, Inc')
ON CONFLICT (did) DO UPDATE 
SET dname = EXCLUDED.dname;
```

В данном примере предполагается, что определён уникальный индекс, ограничивающий значения в столбце `did`:

```
INSERT INTO distributors (did, dname) VALUES 
	(7, 'Redline GmbH')
ON CONFLICT (did) DO NOTHING;
```

Предложение `WHERE` позволяет ограничить набор фактически изменяемых строк (однако любая существующая строка, не подлежащая изменению, всё же будет заблокирована):
```
-- Не менять данные существующих дистрибьюторов в зависимости от почтового индекса
INSERT INTO distributors AS d (did, dname) VALUES 
	(8, 'Anvil Distribution')
ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode <> '21201';
```

```
-- Указать имя ограничения непосредственно в операторе (связанный индекс применяется для принятия решения о выполнении действия DO NOTHING)
INSERT INTO distributors (did, dname) VALUES 
	(9, 'Antwerp Design')
ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
```

```

-- Этот оператор может выбрать частичный уникальный индекс по "did" с предикатом "WHERE is_active", а может и просто использовать обычное ограничение уникальности по столбцу "did"
INSERT INTO distributors (did, dname) VALUES 
	(10, 'Conrad International')
ON CONFLICT (did) WHERE is_active DO NOTHING;
```

##### SELECT
