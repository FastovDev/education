##### IN / NOT IN / EXIST / NOT EXIST
`IN` позволяет проверить вхождение левой части запроса в правую часть. `EXIST` можно считать аналогом `IN`, только отличающийся синтаксисом.

Пример:
```SQL
SELECT name, start_year 
FROM students 
WHERE stud_id IN ( 
	SELECT stud_id 
	FROM exams 
	WHERE course_no = 'CS305' 
);
```

```SQL
SELECT name, start_year 
FROM students 
WHERE EXISTS ( 
	SELECT stud_id 
	FROM exams 
	WHERE grade < 5 AND 
		  exams.stud_id = students.stud_id 
);
```

`NOT IN` позволяет проверить отсутствие вхождения левой части запроса в правую часть. `NOT EXIST` можно считать аналогом `NOT IN`, только отличающийся синтаксисом.

Пример:
```SQL
SELECT name, start_year 
FROM students 
WHERE stud_id NOT IN (
	SELECT stud_id 
	FROM exams 
	WHERE grade < 5
);
```

```SQL
SELECT name, start_year 
FROM students 
WHERE NOT EXISTS ( 
	SELECT stud_id 
	FROM exams 
	WHERE grade < 5 AND 
		  exams.stud_id = students.stud_id 
);
```

##### ORDER BY ASC / DESC

`ORDER BY` позволяет отсортировать результирующий набор по какому-либо столбцу или группе столбцов. Если указывается группа столбцов, то в данные сортируются в порядке очередности их указания. 

После каждого столбца можно указать направление сортировки, либо в возрастающем порядке, либо в убывающем порядке, `ASC`  и `DESC` соответственно. 

Пример:
```SQL
SELECT * 
FROM exams 
ORDER BY grade, stud_id, course_no;
```

##### Агрегирующие функции

Функции этого типа позволяют вычислить какое-то значение, которое будет выведено в одной строке на основании данных в столбце. 

Примеры:
- count - вычисляет количество строк данных в столбце
- avg - вычисляет среднее значение данных в столбце
- sum - суммирует все значения данных в столбце
- min - находит минимальное значение данных в столбце
- max - находит максимальное значение данных в столбце

Пример запроса:
```SQL
SELECT 
	count(*), 
	count(DISTINCT stud_id), 
	avg(grade) 
FROM exams;
```

В примере используются сразу 3 агрегирующие функции. Первая находит количество всех записей в таблице, вторая находит уникальное количество значений столбца, а третья находит среднее значение оценок в столбце.  Если бы мы в первой функции указали `DISTINCT`, как во второй, то мы находили бы не уникальное значение столбца, а уникальные строки, то есть сравнивали бы все столбцы и убирали бы только те строки, значения которых повторяются в каждом столбце.

В примере выше использовались только агрегирующие функции и в результирующей строке мы получали таблицу на 3 столбца с скалярными значениями внутри. Но, иногда мы хотим получить значения внутри какой-то группы, например мы хотели бы получить количество записей с оценкой 5, 4 и ниже 4. Для такого примера отлично подойдет группировка по полю grade. В данном случае grade будет нашим ключом. Все записи, которые соответствуют ключу будут обработано отдельно, не смешиваясь, как будто бы у нас отдельно посчитались все значения с оценкой 5, отдельно все значения с оценкой 4 и т.д.

Пример:
```SQL
SELECT 
	grade,
	count(*)	 
FROM exams;
GROUP BY grade
```

Стоит обратить внимание, что все столбцы, к которым не были применены агрегирующие функции, при наличии хотя бы одной агрегирующей функции в запросе, должны быть указаны в группировке, иначе БД просто не сможет провести схлопывание данных при подсчете записей.

У агрегации есть несколько особенностей. Она не обрабатывает значения NULL, кроме функции count. Она всегда возвращает одну строку, даже если она пустая. Например, когда условие WHERE отсекло весь набор данных, одна строка, хоть и пустая, все равно будет возвращена, если не была применена группировка. С группировкой мы получим пустой результат и 0 строк. 
##### HAVING

Условие WHERE, применяемое для фильтрации значений, не будет работать с командой GROUP BY, так как фильтрация применяется до группировки. Но необходимость фильтрации по агрегированным значениям все равно возникает. Для этого используют команду HAVING. Эта команда фильтрует сгруппированный набор данных по какой-то агрегирующей функции. 

Например:

```SQL
SELECT stud_id 
FROM exams 
WHERE grade = 5 
GROUP BY stud_id 
HAVING count(*) > 1;
```

Данный запрос получил идентификатор студента, который получил 5 в предметах больше 1 раза. Интересной особенностью запроса является то, что хотя мы в результирующем наборе на возвращали результат агрегирующей функции, тем не менее в HAVING мы успешно смогли посчитать количество строк по каждому ключу группировки.

