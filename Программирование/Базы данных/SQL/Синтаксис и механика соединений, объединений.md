Делать выборку из нескольких таблиц через декартовое произведение - путь плохой, мало того, что никаких новых данных мы не получим, режим отображения будет по факту все со всеми, а нагрузка на базу будет неоправданно большая.

Поэтому для выборки данных из нескольких таблиц обычно используются соединения. Соединения бывают нескольких вариантов. Эти варианты определяют конечные результат соединения данных таблиц по какому-то варианту фильтрации строк второй таблицы по отношению к первой. При этом возможно использовать оператор WHERE для фильтрации первой таблицы. 
##### JOIN
Базовая вариация соединения это использование `JOIN`, который по факту является сокращенным вариантом `INNER JOIN`. У соединения есть условие фильтрации присоединяемой таблицы к основной. Разберем пример: 
```SQL
SELECT students.name, exams.grade 
FROM students 
JOIN exams ON students.stud_id = exams.stud_id 
WHERE course_no = 'CS305'
```

В примере мы берем имя студента из одной таблицы и его оценки на экзамене из другой таблицы. Основной таблицей (указание таблицы в `FROM`) является таблица students. К ней мы присоединяем таблицу exams. Условие фильтрации таблицы exams находится в инструкции после `ON`. Мы сравниваем уникальный идентификатор студента, которые существует в обоих таблицах. В зависимости от варианта соединения, будет разная обработка такой связи. В случае обычного `JOIN` используется вариант, который ищет уникальные идентификаторы студентов в обоих таблицах. Если в левой (основной) таблице есть идентификаторы, которых нет в правой (присоединяемой), они не будут показаны в результирующем наборе. Аналогично в обратную сторону. То есть в результирующем наборе появятся только пересекающиеся данные по условию сравнения. 
Предварительно, основная таблица отфильтруется согласно условию WHERE. 
##### LEFT JOIN
Работает аналогично JOIN, только из основной таблицы возьмутся все записи, а не только пересечение. Для значений, которые не имеют пересечения с правой таблицей будут проставлены значения NULL.
##### RIGHT JOIN
Обратный вариант JOIN, полная выборка будет из правой таблицы, помимо пересечения, для отсутствующих значений основной таблицы будут проставлены значения NULL.
##### FULL JOIN
Делает полную выборку из двух таблиц. 
##### Псевдонимы
При соединении множества таблиц запрос может получиться очень громоздким. Кроме того, иногда в запросе одна таблица может участвовать больше одного раза, что будет приводить к неопределенности при выборе колонок нужной таблицы. Поэтому, для уменьшения неопределенности и размера скрипта есть механизм присваивания таблице псевдонима. Псевдоним указывается после названия таблицы. В запросе после указания псевдонима для таблицы при указании атрибутов указывается псевдоним. 

Пример:
```SQL
SELECT 
	f.flight_no, 
	f.departure_airport AS d_airport, 
	dep.city AS d_city, 
	f.arrival_airport AS a_airport, 
	arr.city AS a_city 
FROM flights f 
	JOIN airports dep 
		ON f.departure_airport = dep.airport_code
	JOIN airports arr 
		ON f.arrival_airport = arr.airport_code 
WHERE f.status = 'Departed' AND 
	  f.scheduled_arrival < bookings.now();
```

##### Подзапросы
Учитывая, что каждый запрос начинающийся с `SELECT` возвращает либо табличное выражение, либо скалярное, мы можем использовать подзапросы для формирования определенных данных в промежуточных вычисления и использовать их как таблицы. Если `SELECT` возвращает единичное скалярное значение, то в этом случае это будет не таблица а единичное значение, которое можно использовать, например, в условиях фильтрации. 

Пример использования подзапроса со скалярным значением:
```SQL
SELECT 
	f.flight_no, 
	f.departure_airport AS d_airport, 
	( SELECT city 
	  FROM airports 
	  WHERE airport_code = f.departure_airport 
	) AS d_city, 
	f.arrival_airport AS a_airport, 
	( SELECT city 
	  FROM airports 
	  WHERE airport_code = f.arrival_airport 
	) AS a_city 
FROM flights f 
WHERE f.status = 'Departed' AND 
f.scheduled_arrival < bookings.now();
```
Запрос интересен тем, что вычисления подзапроса происходит во время выборки, без явного использования соединений или объединений, хотя по факту такие подзапросы будут преобразованы в соединение. Поэтому, если используется одна таблица для подзапроса, для улучшения эффективности запроса стоит использовать явное соединение, потому что подзапрос не будет хранить промежуточные результаты для дальнейших вычислений. 
Второй момент. что использование подзапроса в данном примере может вызывать ошибку, если вдруг какой-то подзапрос вернет не скалярное, а табличное представление. Кроме того, данных может не найтись и тогда подзапрос вернет значение NULL, что в разных базах может быть обработано по разному. Где-то это вернет ошибку, где-то подставит значение NULL (например, `PostgreSQL`). 

##### UNION
Операция используется для объединения данных, совпадающих по своим названиям. При этом данные не обязательно должны браться из одной таблицы, главное чтобы совпадали типы данных, общее количество столбцов и их имена. 

```SQL
SELECT * 
FROM aircrafts 
WHERE range > 4500 
UNION 
SELECT * 
FROM aircrafts 
WHERE range < 7500;
```

В примере выше данные по полетам, с длиной маршрута меньше 4500 и больше 7500 объединены в один результирующий набор. При этом дублирующие строки из таблицы не были взяты.  При использовании команды `UNION ALL` будут взяты все строки, в том числе дубликаты. Это не актуально на примере выше, но актуально в следующем примере:

```SQL
SELECT * 
FROM aircrafts 
WHERE range > 4500 
UNION ALL 
SELECT * 
FROM aircrafts 
WHERE range < 7500;
```

Похожие наборы данных мы можем воплотить с помощью других команд, например операций пересечения и разности наборов данных. 

В следующем примере мы получим совпадающие результаты (пересечение набора данных) в разных запросах. 

```SQL
SELECT * 
FROM aircrafts 
WHERE range > 4500 
INTERSECT 
SELECT * 
FROM aircrafts 
WHERE range < 7500;
```

В следующем примере мы вычтем совпадающие результаты второго набора из первого набора данных (разница набора данных). При этом мы не будет добавлять никакие данные из второго набора. 

```SQL
SELECT * 
FROM aircrafts 
WHERE range > 4500 
EXCEPT 
SELECT * 
FROM aircrafts 
WHERE range < 7500;
```

