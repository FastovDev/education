**Анти-паттерн №1. «Control Freak».**
Все зависимости контролируются напрямую. Противоположность принципу инверсии управления.

**Анти-паттерн №2. «Bastard Injection».**
Данный пункт подразумевает множественные перегрузки конструкторов вместе с «конструкторами по умолчанию», которые повсеместно встречаются в .Net, включая BCL. Основная проблема в том, что внешние зависимости обычно определены в других модулях и подобные конструкторы увеличивают связность системы буквально на пустом месте.

**Анти-паттерн №3. «Constrained Construction».**
Анти-паттерн возникает, если существует требование ко всем зависимостям иметь «особенный» конструктор. Данное требование зачастую проистекает из желания «однотипно создавать через Reflection». Что-то типа:

**Анти-паттерн №4. «Service Locator».**
Анти-паттерн возникает при гранулированном получении отдельных сервисов в различных частях кода.
Суть паттерна Сервис Локатор сводится к тому, что вместо создания конкретных объектов («сервисов») напрямую с помощью ключевого слова **new**, мы будем использовать специальный «фабричный» объект, который будет отвечать за создание, а точнее «нахождение» всех сервисов.

// Статический "локатор"
public static class ServiceLocator
{    
	public static object GetService(Type type) {}     
	public static T GetService<T>() {}
}
 
// Сервис локатор в виде интерфейса
public interface IServiceLocator
{   
    T GetService<T>();
}