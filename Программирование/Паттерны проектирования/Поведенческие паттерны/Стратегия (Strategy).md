#### 1. Что такое паттерн **Strategy**?

**Паттерн Strategy** — это поведенческий паттерн, который позволяет определить семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми. Этот паттерн позволяет изменять поведение объекта во время выполнения, предоставляя возможность выбирать нужный алгоритм в зависимости от контекста.

**Основная идея:** вместо того, чтобы иметь одну большую сложную ветвь с различными условиями (например, if-else или switch), паттерн **Strategy** предлагает использовать отдельные классы для разных алгоритмов и позволяет выбрать нужный алгоритм через интерфейс.

#### 2. Когда применять паттерн **Strategy**?

**Strategy** следует применять в следующих случаях:

- **Когда алгоритмы могут изменяться в зависимости от контекста.** Например, когда приложение должно выполнять схожие действия, но с разными подходами в разных ситуациях (например, различные способы сортировки или валидации).
- **Когда есть много вариантов поведения, и каждый алгоритм может быть заменён.** Например, разные способы расчёта налогов в зависимости от типа пользователя или региона.
- **Когда необходимо избежать громоздкой условной логики (if-else, switch-case).** Это помогает сделать код более чистым, гибким и расширяемым.

#### 3. Когда не применять паттерн **Strategy**?

**Не следует применять паттерн, если:**

- **Алгоритм статичен.** Если алгоритм никогда не меняется или меняется крайне редко, использование паттерна может быть избыточным.
- **Алгоритмы слишком похожи.** Если различные реализации алгоритмов не сильно различаются, возможно, проще будет оставить их в одном методе с условиями.
- **Невозможность добавления новых алгоритмов.** В случаях, когда расширяемость не важна, использование паттерна будет лишним.

#### 4. Когда применять что-то вместе с **Strategy**?

В некоторых случаях полезно комбинировать паттерн **Strategy** с другими паттернами, например:

- **Factory**: если алгоритмы создаются динамически и их выбор зависит от внешних факторов, можно использовать паттерн **Factory** для создания подходящей стратегии.
- **Composite**: если стратегия должна работать с несколькими другими стратегиями, объединёнными в одно целое (например, несколько видов алгоритмов для разных типов данных).
- **Decorator**: если нужно модифицировать поведение алгоритма без изменения его исходной реализации.

#### 5. Примеры реализации паттерна **Strategy**

##### Пример 1: Простой пример с сортировкой

Предположим, что у нас есть несколько стратегий сортировки: быстрая сортировка, сортировка слиянием и пузырьковая сортировка. Мы хотим, чтобы пользователь мог выбрать нужную стратегию сортировки в зависимости от контекста.

```C#
// Интерфейс стратегии
public interface ISortStrategy
{
    void Sort(List<int> list);
}

// Конкретная стратегия: Быстрая сортировка
public class QuickSort : ISortStrategy
{
    public void Sort(List<int> list)
    {
        list.Sort(); // Для простоты пример
        Console.WriteLine("Использована быстрая сортировка.");
    }
}

// Конкретная стратегия: Сортировка слиянием
public class MergeSort : ISortStrategy
{
    public void Sort(List<int> list)
    {
        list.Sort(); // Для простоты пример
        Console.WriteLine("Использована сортировка слиянием.");
    }
}

// Контекст, использующий стратегию
public class SortContext
{
    private ISortStrategy _sortStrategy;

    public SortContext(ISortStrategy sortStrategy)
    {
        _sortStrategy = sortStrategy;
    }

    public void SetStrategy(ISortStrategy sortStrategy)
    {
        _sortStrategy = sortStrategy;
    }

    public void ExecuteSort(List<int> list)
    {
        _sortStrategy.Sort(list);
    }
}

// Использование
class Program
{
    static void Main(string[] args)
    {
        List<int> numbers = new List<int> { 4, 2, 9, 1 };

        // Выбираем стратегию
        SortContext context = new SortContext(new QuickSort());
        context.ExecuteSort(numbers);  // Использована быстрая сортировка

        context.SetStrategy(new MergeSort());
        context.ExecuteSort(numbers);  // Использована сортировка слиянием
    }
}

```

##### Пример 2: Паттерн Strategy для расчёта налога

Допустим, у нас есть различные типы налогов в зависимости от типа пользователя (например, для физических и юридических лиц).

```C#
// Интерфейс стратегии
public interface ITaxStrategy
{
    decimal CalculateTax(decimal income);
}

// Конкретная стратегия для физических лиц
public class IndividualTaxStrategy : ITaxStrategy
{
    public decimal CalculateTax(decimal income)
    {
        return income * 0.2m; // 20% налог
    }
}

// Конкретная стратегия для юридических лиц
public class CorporateTaxStrategy : ITaxStrategy
{
    public decimal CalculateTax(decimal income)
    {
        return income * 0.3m; // 30% налог
    }
}

// Контекст, который использует стратегию
public class TaxContext
{
    private ITaxStrategy _taxStrategy;

    public TaxContext(ITaxStrategy taxStrategy)
    {
        _taxStrategy = taxStrategy;
    }

    public void SetTaxStrategy(ITaxStrategy taxStrategy)
    {
        _taxStrategy = taxStrategy;
    }

    public decimal ExecuteTaxCalculation(decimal income)
    {
        return _taxStrategy.CalculateTax(income);
    }
}

// Использование
class Program
{
    static void Main(string[] args)
    {
        decimal income = 1000m;

        // Применение стратегии для физических лиц
        TaxContext context = new TaxContext(new IndividualTaxStrategy());
        Console.WriteLine($"Налог для физического лица: {context.ExecuteTaxCalculation(income)}");

        // Применение стратегии для юридических лиц
        context.SetTaxStrategy(new CorporateTaxStrategy());
        Console.WriteLine($"Налог для юридического лица: {context.ExecuteTaxCalculation(income)}");
    }
}

```

#### 6. Плюсы и минусы паттерна **Strategy**

##### Плюсы:

- **Гибкость в выборе алгоритмов**: можно динамически изменять поведение объекта, выбирая стратегию.
- **Изоляция алгоритмов**: каждый алгоритм инкапсулируется в своём собственном классе, что делает код более чистым, расширяемым и тестируемым.
- **Уменьшение условных конструкций**: вместо множества if-else или switch-case создаётся гибкая система, в которой легко добавлять новые алгоритмы без изменений в существующих классах.
- **Повторное использование**: одна и та же стратегия может быть использована в разных местах, что уменьшает дублирование кода.

##### Минусы:

- **Усложнение системы**: если алгоритмов немного и они не изменяются часто, применение паттерна может быть избыточным.
- **Увеличение количества классов**: каждый новый алгоритм требует создания отдельного класса, что может привести к большому числу классов в системе, если алгоритмов много.

#### 7. Использование паттерна **Strategy** в базовых библиотеках C# и ASP.NET Core

В **C#** и **ASP.NET Core** паттерн **Strategy** используется не так явно, но похожие концепции применяются в некоторых библиотеках:

- В **Entity Framework** для работы с разными типами хранилищ можно использовать абстракции, подобные стратегиям, например, в контексте различных провайдеров базы данных.
- В **ASP.NET Core** для обработки запросов можно использовать делегаты и обработчики, которые работают по аналогии с паттерном **Strategy** (например, выбор типа аутентификации или авторизации в зависимости от контекста).

Также, часто встречаются **интерфейсы** и **слои абстракции**, которые могут быть использованы для реализации похожих концепций, таких как обработка различных типов входных данных или выбор разных реализаций бизнес-логики в зависимости от контекста.

### Заключение

Паттерн **Strategy** — это мощный инструмент для организации гибкой архитектуры, позволяющий эффективно изменять алгоритмы поведения объектов без необходимости вносить изменения в их код. Он полезен в ситуациях, когда алгоритмы могут изменяться в зависимости от контекста, и когда важно избавиться от громоздкой условной логики. Однако, как и с любым паттерном, важно не злоупотреблять им, чтобы не усложнить систему без особой необходимости.