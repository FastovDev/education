**Mediator Pattern** (Паттерн Посредника) — это поведенческий паттерн проектирования, который позволяет объектам взаимодействовать между собой через посредника, а не напрямую. Вместо того чтобы объекты взаимодействовали друг с другом напрямую, они отправляют свои сообщения посреднику, который затем решает, как и кому передать эти сообщения.

Этот паттерн помогает уменьшить количество зависимостей между объектами, упрощая их взаимодействие. Он является особенно полезным в сложных системах, где много объектов взаимодействуют между собой, и можно централизовать логику коммуникации.

### Основные принципы Mediator Pattern

- **Посредник (Mediator)** — центральный объект, который управляет взаимодействием между объектами.
- **Коллеги (Colleagues)** — объекты, которые взаимодействуют через посредника, но не знают друг о друге напрямую.

### Как это работает?

Вместо того чтобы объекты напрямую вызывали методы друг друга, они отправляют сообщения (команды или запросы) посреднику. Посредник обрабатывает логику взаимодействия, передавая сообщение нужным объектам.

Пример:

1. Объект A отправляет сообщение посреднику.
2. Посредник анализирует сообщение и решает, какой объект должен его обработать.
3. Посредник передает сообщение нужному объекту B.

### Применение Mediator Pattern в бизнес-логике

Медиатор полезен в бизнес-логике, когда вы хотите централизовать взаимодействие между различными частями системы, уменьшив зависимость между компонентами.

Примеры применения в бизнес-логике:

- **Обработка событий**: Когда множество компонентов должны реагировать на одно событие, медиатор может централизованно обработать это событие и уведомить все заинтересованные компоненты.
- **Сложная логика взаимодействия между объектами**: Когда объекты в системе должны взаимодействовать друг с другом, но при этом важно уменьшить их взаимные зависимости, медиатор позволяет сделать этот процесс более гибким и понятным.
- **Реализация команд и запросов**: Вместо того чтобы вызывать методы других объектов, можно создать команды, которые медиатор будет направлять в соответствующие обработчики.

### Когда стоит использовать Mediator Pattern?

4. **Уменьшение зависимости между объектами**: Когда объекты в вашей системе имеют много связей между собой и вам нужно уменьшить эти зависимости, централизовав логику взаимодействия.
5. **Много взаимодействующих компонентов**: Когда в системе несколько компонентов, которые должны взаимодействовать, но без явных зависимостей друг от друга.
6. **Централизованная обработка логики**: Когда важно централизованно управлять бизнес-логикой взаимодействия между объектами, чтобы улучшить читабельность и поддержку кода.
7. **Обработка событий и команд**: Когда нужно организовать гибкую и расширяемую обработку команд и событий (например, при использовании паттерна Mediator в сочетании с CQRS для обработки команд и запросов).
8. **Сложные интерфейсы взаимодействия**: Когда взаимодействие между объектами становится сложным или запутанным, и вы хотите упростить эту логику.

### Пример использования Mediator Pattern

Давайте рассмотрим пример применения Mediator Pattern с использованием **MediatR** в ASP.NET Core, который позволяет централизованно обрабатывать команды и запросы.

9. **Добавление NuGet-пакета:**
    
    bash
    
```sh
dotnet add package MediatR

```
    
10. **Создание команды (Command):** Команда представляет собой объект, который будет инициировать некоторое действие:
    
```C#
public class CreateUserCommand : IRequest<User>
{
    public string Name { get; set; }
    public string Email { get; set; }
}

```
    
11. **Создание обработчика команды (Handler):** Обработчик будет управлять выполнением команды:
    
```C#
public class CreateUserCommandHandler : IRequestHandler<CreateUserCommand, User>
{
    private readonly IUserRepository _userRepository;

    public CreateUserCommandHandler(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public async Task<User> Handle(CreateUserCommand request, CancellationToken cancellationToken)
    {
        var user = new User
        {
            Name = request.Name,
            Email = request.Email
        };
        await _userRepository.AddAsync(user);
        return user;
    }
}

```
1. **Использование Mediator в контроллере:** В контроллере мы вызываем медиатор, чтобы обработать команду:
    
```C#
[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    private readonly IMediator _mediator;

    public UserController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserCommand command)
    {
        var user = await _mediator.Send(command);
        return CreatedAtAction(nameof(GetUserById), new { id = user.Id }, user);
    }
}

```

### Преимущества Mediator Pattern

2. **Уменьшение связности**: Объекты не зависят друг от друга напрямую, что облегчает поддержку и тестирование системы.
3. **Централизованное управление взаимодействиями**: Логика взаимодействия между компонентами управляется в одном месте (медиаторе), что упрощает ее изменение и расширение.
4. **Упрощение взаимодействия**: Если у вас есть несколько компонентов, которые должны взаимодействовать, медиатор делает это взаимодействие более прозрачным и менее зависимым.
5. **Улучшенная тестируемость**: Тестирование компонентов становится проще, так как объекты не зависят от других объектов напрямую.
6. **Гибкость**: Вы можете добавлять новые команды и обработчики без изменения существующего кода взаимодействующих компонентов.

### Когда не стоит использовать Mediator Pattern?

7. **Простые приложения**: В маленьких и простых приложениях Mediator Pattern может быть избыточным, так как взаимодействие между объектами будет достаточно простым и прямым.
8. **Высокая сложность**: В сложных приложениях Mediator может привести к перегрузке и путанице, если не будет правильно спроектирован. Например, когда слишком много обработчиков и команд может затруднить отслеживание логики.
9. **Невозможность разделения логики**: Если в вашей системе нет явного разделения между компонентами, которые взаимодействуют, то использование посредника может быть непродуктивным. Например, если взаимодействие между объектами настолько тесное, что их нельзя легко разделить.
10. **Производительность**: В некоторых случаях использование медиатора может привести к небольшой потере производительности, так как посредник добавляет дополнительный уровень абстракции в систему.

### Заключение

Mediator Pattern — это мощный инструмент для упрощения взаимодействия между объектами в системе, особенно когда у вас есть множество компонентов, которые должны взаимодействовать друг с другом. Он помогает уменьшить зависимости, централизовать логику и улучшить тестируемость системы. Однако его не стоит использовать в случаях, когда приложение простое или взаимодействие между объектами слишком тесное.