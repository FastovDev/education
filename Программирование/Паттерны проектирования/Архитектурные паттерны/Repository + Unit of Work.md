Паттерны **Repository** и **Unit of Work** часто применяются вместе, особенно в приложениях, где необходимо взаимодействие с базой данных или другими хранилищами данных. Они помогают организовать доступ к данным, обеспечивая абстракцию от конкретной реализации хранения данных и улучшая управление транзакциями.

### 1. Паттерн **Repository**

#### Что такое Repository?

Паттерн **Repository** предоставляет абстракцию над коллекцией объектов, которые можно хранить в хранилище данных. Основная цель — отделить бизнес-логику от деталей работы с базой данных или другими хранилищами.

**Основные задачи паттерна Repository:**

- Скрыть детали работы с данными.
- Упростить работу с коллекциями объектов.
- Служить интерфейсом для доступа к данным.

**Пример реализации**:

```C#
public interface IProductRepository
{
    Task<Product> GetByIdAsync(int id);
    Task<IEnumerable<Product>> GetAllAsync();
    Task AddAsync(Product product);
    Task UpdateAsync(Product product);
    Task DeleteAsync(int id);
}

```

**Пример реализации репозитория**:

```C#
public class ProductRepository : IProductRepository
{
    private readonly DbContext _context;

    public ProductRepository(DbContext context)
    {
        _context = context;
    }

    public async Task<Product> GetByIdAsync(int id)
    {
        return await _context.Products.FindAsync(id);
    }

    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        return await _context.Products.ToListAsync();
    }

    public async Task AddAsync(Product product)
    {
        await _context.Products.AddAsync(product);
    }

    public async Task UpdateAsync(Product product)
    {
        _context.Products.Update(product);
    }

    public async Task DeleteAsync(int id)
    {
        var product = await _context.Products.FindAsync(id);
        if (product != null)
        {
            _context.Products.Remove(product);
        }
    }
}

```

#### Когда применять Repository?

- Когда нужно скрыть детали работы с базой данных, делая код более гибким и тестируемым.
- Когда необходимо работать с коллекциями объектов, абстрагируя их работу с базой данных.
- Когда необходимо использовать разные источники данных (например, работу с несколькими базами данных или API), и вы хотите обеспечить единый интерфейс для всех.

#### Когда не применять Repository?

- В небольших проектах, где база данных проста и не имеет сложной логики запросов.
- Когда вам не требуется абстракция данных, а доступ к базе данных прост и очевиден.
- В приложениях, где предполагается низкая нагрузка и отсутствие сложных бизнес-правил, что делает абстракции избыточными.

#### Плюсы Repository:

- **Изоляция от источников данных**: позволяет легко заменять технологию хранилища (например, переключаться с SQL на NoSQL).
- **Упрощение бизнес-логики**: бизнес-логика работает с объектами и коллекциями, а не с SQL-запросами или другим специфическим кодом доступа к данным.
- **Упрощение тестирования**: репозитории можно замокать или подменить для юнит-тестирования.

#### Минусы Repository:

- **Избыточность для простых проектов**: если проект небольшой или не требует сложной логики доступа к данным, создание репозитория может быть лишним.
- **Усложнение тестирования в случае неправильной реализации**: если репозиторий плохо спроектирован, это может усложнить тестирование.

---

### 2. Паттерн **Unit of Work**

#### Что такое Unit of Work?

Паттерн **Unit of Work** — это паттерн, который управляет транзакциями и отслеживает изменения объектов в рамках одной транзакции. Он координирует работу с несколькими репозиториями и следит за тем, чтобы все изменения, сделанные в бизнес-логике, были сохранены в одном месте, как единая транзакция.

**Основные задачи паттерна Unit of Work:**

- Управление транзакциями: начало, коммит и откат транзакции.
- Координация работы с несколькими репозиториями.
- Сохранение всех изменений в хранилище данных как единое целое.

**Пример реализации**:

```C#
public interface IUnitOfWork
{
    IProductRepository ProductRepository { get; }
    IOrderRepository OrderRepository { get; }
    Task<int> CompleteAsync(); // Сохранение всех изменений
}

```

```C#
public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext _context;

    public UnitOfWork(DbContext context)
    {
        _context = context;
        ProductRepository = new ProductRepository(context);
        OrderRepository = new OrderRepository(context);
    }

    public IProductRepository ProductRepository { get; }
    public IOrderRepository OrderRepository { get; }

    public async Task<int> CompleteAsync()
    {
        return await _context.SaveChangesAsync();
    }
}

```

#### Когда применять Unit of Work?

- Когда необходимо координировать работу с несколькими репозиториями в рамках одной транзакции.
- Когда нужно гарантировать, что все изменения в системе будут сохранены в одном атомарном блоке.
- Когда нужно следить за состоянием изменений объектов (например, если объект был изменён или добавлен, и это нужно учесть при сохранении).

#### Когда не применять Unit of Work?

- В проектах с простой логикой, где достаточно лишь репозитория для работы с данными и транзакции не требуются.
- В проектах, где есть лишь одна операция с базой данных и нет необходимости в сложной координации нескольких репозиториев.

#### Плюсы Unit of Work:

- **Целостность данных**: гарантирует, что все изменения, сделанные в контексте одной операции, будут зафиксированы или откатаны одновременно.
- **Координация репозиториев**: удобен, когда необходимо работать с несколькими репозиториями и гарантировать, что их изменения будут сохранены в одном месте.
- **Поддержка транзакций**: позволяет инкапсулировать логику работы с транзакциями.

#### Минусы Unit of Work:

- **Перегрузка для простых случаев**: если приложение не требует сложных транзакционных операций, использование Unit of Work может быть избыточным.
- **Сложность реализации**: добавление этого паттерна может сделать систему более сложной, если транзакции не требуются.

---

### Совмещение Repository и Unit of Work

Когда **Repository** и **Unit of Work** используются вместе, паттерн **Unit of Work** управляет жизненным циклом репозиториев и транзакциями, а репозитории обеспечивают доступ к данным. Вместе они предоставляют удобный способ работы с данными в рамках одной транзакции.

Пример использования:

```C#
public class ProductService
{
    private readonly IUnitOfWork _unitOfWork;

    public ProductService(IUnitOfWork unitOfWork)
    {
        _unitOfWork = unitOfWork;
    }

    public async Task CreateProductAsync(Product product)
    {
        await _unitOfWork.ProductRepository.AddAsync(product);
        await _unitOfWork.CompleteAsync(); // Сохранение всех изменений
    }

    public async Task DeleteProductAsync(int id)
    {
        await _unitOfWork.ProductRepository.DeleteAsync(id);
        await _unitOfWork.CompleteAsync(); // Сохранение всех изменений
    }
}

```

### Преимущества сочетания Repository и Unit of Work:

- **Управление транзакциями**: позволяет работать с несколькими репозиториями и сохранять изменения в одном месте.
- **Упрощение работы с данными**: абстрагирует доступ к данным и управление транзакциями, улучшая тестируемость и поддержку.
- **Поддержка бизнес-логики**: репозитории позволяют работать с бизнес-объектами, а Unit of Work следит за целостностью данных.

### Схожие технологии

1. **ORM (Object-Relational Mapping)**: такие как **Entity Framework**, которые могут обеспечивать функциональность, схожую с Repository и Unit of Work. Например, **Entity Framework** реализует паттерн **Unit of Work** через `DbContext`, который управляет транзакциями и репозиториями.
    
2. **Data Mapper**: паттерн, который схож с **Repository** и используется для маппинга объектов в базу данных, но в отличие от **Repository**, его цель — не абстракция коллекций данных, а именно маппинг данных.
    
3. **Transaction Script**: в отличие от **Unit of Work**, этот паттерн предполагает управление транзакциями на уровне отдельных операций (методов), а не через общий координирующий объект.
    

---

### Заключение

Паттерны **Repository** и **Unit of Work** полезны в средних и крупных проектах, где требуется абстрагировать доступ к данным и управлять транзакциями. **Repository** помогает работать с данными, а **Unit of Work** координирует работу с несколькими репозиториями, обеспечивая целостность данных. Вместе они помогают организовать код так, чтобы он был гибким, модульным и тестируемым. Однако для простых приложений или в случае, когда транзакции не требуются, эти паттерны могут быть избыточными.